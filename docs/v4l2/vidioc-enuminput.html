<?xml version="1.0" encoding="ANSI_X3.4-1968" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=ANSI_X3.4-1968" /><title>ioctl VIDIOC_ENUMINPUT</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="index.html" title="LINUX MEDIA INFRASTRUCTURE API" /><link rel="up" href="user-func.html" title="Appendix&#160;A.&#160;Function Reference" /><link rel="prev" href="vidioc-enum-freq-bands.html" title="ioctl VIDIOC_ENUM_FREQ_BANDS" /><link rel="next" href="vidioc-enumoutput.html" title="ioctl VIDIOC_ENUMOUTPUT" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">ioctl VIDIOC_ENUMINPUT</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="vidioc-enum-freq-bands.html">Prev</a>&#160;</td><th width="60%" align="center">Appendix&#160;A.&#160;Function Reference</th><td width="20%" align="right">&#160;<a accesskey="n" href="vidioc-enumoutput.html">Next</a></td></tr></table><hr /></div><div class="refentry" title="ioctl VIDIOC_ENUMINPUT"><a id="vidioc-enuminput"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_ENUMINPUT &#8212; Enumerate video inputs</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td>&#160;</td><td>int <var class="pdparam">request</var>, </td></tr><tr><td>&#160;</td><td>struct v4l2_input
*<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&#160;</div></div></div><div class="refsect1" title="Arguments"><a id="idp33194568"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="func-open.html" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_ENUMINPUT</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp33198656"></a><h2>Description</h2><p>To query the attributes of a video input applications
initialize the <em class="structfield"><code>index</code></em> field of struct&#160;<a class="link" href="vidioc-enuminput.html#v4l2-input" title="Table&#160;A.35.&#160;struct v4l2_input">v4l2_input</a>
and call the <code class="constant">VIDIOC_ENUMINPUT</code> ioctl with a
pointer to this structure. Drivers fill the rest of the structure or
return an <span class="errorcode">EINVAL</span> error code when the index is out of bounds. To enumerate all
inputs applications shall begin at index zero, incrementing by one
until the driver returns <span class="errorcode">EINVAL</span>.</p><div class="table"><a id="v4l2-input"></a><p class="title"><b>Table&#160;A.35.&#160;struct <span class="structname">v4l2_input</span></b></p><div class="table-contents"><table summary="struct v4l2_input" width="100%" border="0"><colgroup><col /><col /><col /></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>index</code></em></td><td valign="top">Identifies the input, set by the
application.</td></tr><tr><td valign="top">__u8</td><td valign="top"><em class="structfield"><code>name</code></em>[32]</td><td valign="top">Name of the video input, a NUL-terminated ASCII
string, for example: "Vin (Composite 2)". This information is intended
for the user, preferably the connector label on the device itself.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the input, see <a class="xref" href="vidioc-enuminput.html#input-type" title="Table&#160;A.36.&#160;Input Types">Table&#160;A.36, &#8220;Input Types&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>audioset</code></em></td><td valign="top"><p>Drivers can enumerate up to 32 video and
audio inputs. This field shows which audio inputs were selectable as
audio source if this was the currently selected video input. It is a
bit mask. The LSB corresponds to audio input 0, the MSB to input 31.
Any number of bits can be set, or none.</p><p>When the driver
does not enumerate audio inputs no bits must be set. Applications
shall not interpret this as lack of audio support. Some drivers
automatically select audio sources and do not enumerate them since
there is no choice anyway.</p><p>For details on audio inputs and
how to select the current input see <a class="xref" href="audio.html" title="Audio Inputs and Outputs">the section called &#8220;Audio Inputs and Outputs&#8221;</a>.</p></td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>tuner</code></em></td><td valign="top">Capture devices can have zero or more tuners (RF
demodulators). When the <em class="structfield"><code>type</code></em> is set to
<code class="constant">V4L2_INPUT_TYPE_TUNER</code> this is an RF connector and
this field identifies the tuner. It corresponds to
struct&#160;<a class="link" href="vidioc-g-tuner.html#v4l2-tuner" title="Table&#160;A.82.&#160;struct v4l2_tuner">v4l2_tuner</a> field <em class="structfield"><code>index</code></em>. For details on
tuners see <a class="xref" href="tuner.html" title="Tuners and Modulators">the section called &#8220;Tuners and Modulators&#8221;</a>.</td></tr><tr><td valign="top"><a class="link" href="vidioc-enumstd.html#v4l2-std-id" title="Table&#160;A.44.&#160;typedef v4l2_std_id">v4l2_std_id</a></td><td valign="top"><em class="structfield"><code>std</code></em></td><td valign="top">Every video input supports one or more different
video standards. This field is a set of all supported standards. For
details on video standards and how to switch see <a class="xref" href="standard.html" title="Video Standards">the section called &#8220;Video Standards&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>status</code></em></td><td valign="top">This field provides status information about the
input. See <a class="xref" href="vidioc-enuminput.html#input-status" title="Table&#160;A.37.&#160;Input Status Flags">Table&#160;A.37, &#8220;Input Status Flags&#8221;</a> for flags.
With the exception of the sensor orientation bits <em class="structfield"><code>status</code></em> is only valid when this is the
current input.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>capabilities</code></em></td><td valign="top">This field provides capabilities for the
input. See <a class="xref" href="vidioc-enuminput.html#input-capabilities" title="Table&#160;A.38.&#160;Input capabilities">Table&#160;A.38, &#8220;Input capabilities&#8221;</a> for flags.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[3]</td><td valign="top">Reserved for future extensions. Drivers must set
the array to zero.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="input-type"></a><p class="title"><b>Table&#160;A.36.&#160;Input Types</b></p><div class="table-contents"><table summary="Input Types" width="100%" border="0"><colgroup><col /><col /><col /></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_INPUT_TYPE_TUNER</code></td><td valign="top">1</td><td valign="top">This input uses a tuner (RF demodulator).</td></tr><tr><td valign="top"><code class="constant">V4L2_INPUT_TYPE_CAMERA</code></td><td valign="top">2</td><td valign="top">Analog baseband input, for example CVBS /
Composite Video, S-Video, RGB.</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="input-status"></a><p class="title"><b>Table&#160;A.37.&#160;Input Status Flags</b></p><div class="table-contents"><table summary="Input Status Flags" width="100%" border="0"><colgroup><col /><col align="center" /><col /></colgroup><tbody valign="top"><tr><td colspan="3" align="left" valign="top">General</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_POWER</code></td><td align="center" valign="top">0x00000001</td><td valign="top">Attached device is off.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_SIGNAL</code></td><td align="center" valign="top">0x00000002</td><td valign="top">&#160;</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_COLOR</code></td><td align="center" valign="top">0x00000004</td><td valign="top">The hardware supports color decoding, but does not
detect color modulation in the signal.</td></tr><tr><td colspan="3" align="left" valign="top">Sensor Orientation</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_HFLIP</code></td><td align="center" valign="top">0x00000010</td><td valign="top">The input is connected to a device that produces a signal
that is flipped horizontally and does not correct this before passing the
signal to userspace.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_VFLIP</code></td><td align="center" valign="top">0x00000020</td><td valign="top">The input is connected to a device that produces a signal
that is flipped vertically and does not correct this before passing the
signal to userspace. Note that a 180 degree rotation is the same as HFLIP | VFLIP</td></tr><tr><td colspan="3" align="left" valign="top">Analog Video</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_H_LOCK</code></td><td align="center" valign="top">0x00000100</td><td valign="top">No horizontal sync lock.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_COLOR_KILL</code></td><td align="center" valign="top">0x00000200</td><td valign="top">A color killer circuit automatically disables color
decoding when it detects no color modulation. When this flag is set
the color killer is enabled <span class="emphasis"><em>and</em></span> has shut off
color decoding.</td></tr><tr><td colspan="3" align="left" valign="top">Digital Video</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_SYNC</code></td><td align="center" valign="top">0x00010000</td><td valign="top">No synchronization lock.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_EQU</code></td><td align="center" valign="top">0x00020000</td><td valign="top">No equalizer lock.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_CARRIER</code></td><td align="center" valign="top">0x00040000</td><td valign="top">Carrier recovery failed.</td></tr><tr><td colspan="3" align="left" valign="top">VCR and Set-Top Box</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_MACROVISION</code></td><td align="center" valign="top">0x01000000</td><td valign="top">Macrovision is an analog copy prevention system
mangling the video signal to confuse video recorders. When this
flag is set Macrovision has been detected.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_NO_ACCESS</code></td><td align="center" valign="top">0x02000000</td><td valign="top">Conditional access denied.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_ST_VTR</code></td><td align="center" valign="top">0x04000000</td><td valign="top">VTR time constant. [?]</td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="input-capabilities"></a><p class="title"><b>Table&#160;A.38.&#160;Input capabilities</b></p><div class="table-contents"><table summary="Input capabilities" width="100%" border="0"><colgroup><col /><col /><col /></colgroup><tbody valign="top"><tr><td valign="top"><code class="constant">V4L2_IN_CAP_DV_TIMINGS</code></td><td valign="top">0x00000002</td><td valign="top">This input supports setting video timings by using VIDIOC_S_DV_TIMINGS.</td></tr><tr><td valign="top"><code class="constant">V4L2_IN_CAP_STD</code></td><td valign="top">0x00000004</td><td valign="top">This input supports setting the TV standard by using VIDIOC_S_STD.</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="refsect1" title="Return Value"><a id="idp33246968"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="gen_errors.html#gen-errors" title="Table&#160;19.1.&#160;Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The struct&#160;<a class="link" href="vidioc-enuminput.html#v4l2-input" title="Table&#160;A.35.&#160;struct v4l2_input">v4l2_input</a> <em class="structfield"><code>index</code></em> is
out of bounds.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="vidioc-enum-freq-bands.html">Prev</a>&#160;</td><td width="20%" align="center"><a accesskey="u" href="user-func.html">Up</a></td><td width="40%" align="right">&#160;<a accesskey="n" href="vidioc-enumoutput.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">ioctl VIDIOC_ENUM_FREQ_BANDS&#160;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&#160;ioctl VIDIOC_ENUMOUTPUT</td></tr></table></div></body></html>
