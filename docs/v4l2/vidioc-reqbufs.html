<?xml version="1.0" encoding="ANSI_X3.4-1968" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=ANSI_X3.4-1968" /><title>ioctl VIDIOC_REQBUFS</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2" /><link rel="home" href="index.html" title="LINUX MEDIA INFRASTRUCTURE API" /><link rel="up" href="user-func.html" title="Appendix&#160;A.&#160;Function Reference" /><link rel="prev" href="vidioc-querystd.html" title="ioctl VIDIOC_QUERYSTD" /><link rel="next" href="vidioc-s-hw-freq-seek.html" title="ioctl VIDIOC_S_HW_FREQ_SEEK" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">ioctl VIDIOC_REQBUFS</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="vidioc-querystd.html">Prev</a>&#160;</td><th width="60%" align="center">Appendix&#160;A.&#160;Function Reference</th><td width="20%" align="right">&#160;<a accesskey="n" href="vidioc-s-hw-freq-seek.html">Next</a></td></tr></table><hr /></div><div class="refentry" title="ioctl VIDIOC_REQBUFS"><a id="vidioc-reqbufs"></a><div class="titlepage"></div><div class="refnamediv"><h2>Name</h2><p>VIDIOC_REQBUFS &#8212; Initiate Memory Mapping or User Pointer I/O</p></div><div class="refsynopsisdiv" title="Synopsis"><h2>Synopsis</h2><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" class="funcprototype-table"><tr><td><code class="funcdef">int <b class="fsfunc">ioctl</b>(</code></td><td>int <var class="pdparam">fd</var>, </td></tr><tr><td>&#160;</td><td>int <var class="pdparam">request</var>, </td></tr><tr><td>&#160;</td><td>struct v4l2_requestbuffers *<var class="pdparam">argp</var><code>)</code>;</td></tr></table><div class="funcprototype-spacer">&#160;</div></div></div><div class="refsect1" title="Arguments"><a id="idp36089080"></a><h2>Arguments</h2><div class="variablelist"><dl><dt><span class="term"><em class="parameter"><code>fd</code></em></span></dt><dd><p>File descriptor returned by <a class="link" href="func-open.html" title="V4L2 open()"><code class="function">open()</code></a>.</p></dd><dt><span class="term"><em class="parameter"><code>request</code></em></span></dt><dd><p>VIDIOC_REQBUFS</p></dd><dt><span class="term"><em class="parameter"><code>argp</code></em></span></dt><dd><p></p></dd></dl></div></div><div class="refsect1" title="Description"><a id="idp36093168"></a><h2>Description</h2><p>This ioctl is used to initiate <a class="link" href="mmap.html" title="Streaming I/O (Memory Mapping)">memory mapped</a>,
<a class="link" href="userp.html" title="Streaming I/O (User Pointers)">user pointer</a> or <a class="link" href="dmabuf.html" title="Streaming I/O (DMA buffer importing)">DMABUF</a> based I/O.  Memory mapped buffers are located in
device memory and must be allocated with this ioctl before they can be mapped
into the application's address space. User buffers are allocated by
applications themselves, and this ioctl is merely used to switch the driver
into user pointer I/O mode and to setup some internal structures.
Similarly, DMABUF buffers are allocated by applications through a device
driver, and this ioctl only configures the driver into DMABUF I/O mode without
performing any direct allocation.</p><p>To allocate device buffers applications initialize all fields of the
<span class="structname">v4l2_requestbuffers</span> structure.  They set the
<em class="structfield"><code>type</code></em> field to the respective stream or buffer type,
the <em class="structfield"><code>count</code></em> field to the desired number of buffers,
<em class="structfield"><code>memory</code></em> must be set to the requested I/O method and
the <em class="structfield"><code>reserved</code></em> array must be zeroed. When the ioctl is
called with a pointer to this structure the driver will attempt to allocate the
requested number of buffers and it stores the actual number allocated in the
<em class="structfield"><code>count</code></em> field. It can be smaller than the number
requested, even zero, when the driver runs out of free memory. A larger number
is also possible when the driver requires more buffers to function correctly.
For example video output requires at least two buffers, one displayed and one
filled by the application.</p><p>When the I/O method is not supported the ioctl
returns an <span class="errorcode">EINVAL</span> error code.</p><p>Applications can call <code class="constant">VIDIOC_REQBUFS</code>
again to change the number of buffers, however this cannot succeed
when any buffers are still mapped. A <em class="structfield"><code>count</code></em>
value of zero frees all buffers, after aborting or finishing any DMA
in progress, an implicit <a class="link" href="vidioc-streamon.html" title="ioctl VIDIOC_STREAMON, VIDIOC_STREAMOFF"><code class="constant">VIDIOC_STREAMOFF</code></a>. </p><div class="table"><a id="v4l2-requestbuffers"></a><p class="title"><b>Table&#160;A.94.&#160;struct <span class="structname">v4l2_requestbuffers</span></b></p><div class="table-contents"><table summary="struct v4l2_requestbuffers" width="100%" border="0"><colgroup><col /><col /><col /></colgroup><tbody valign="top"><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>count</code></em></td><td valign="top">The number of buffers requested or granted.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>type</code></em></td><td valign="top">Type of the stream or buffers, this is the same
as the struct&#160;<a class="link" href="vidioc-g-fmt.html#v4l2-format" title="Table&#160;A.67.&#160;struct v4l2_format">v4l2_format</a> <em class="structfield"><code>type</code></em> field. See <a class="xref" href="buffer.html#v4l2-buf-type" title="Table&#160;3.3.&#160;enum v4l2_buf_type">Table&#160;3.3, &#8220;enum v4l2_buf_type&#8221;</a> for valid values.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>memory</code></em></td><td valign="top">Applications set this field to
<code class="constant">V4L2_MEMORY_MMAP</code>,
<code class="constant">V4L2_MEMORY_DMABUF</code> or
<code class="constant">V4L2_MEMORY_USERPTR</code>. See <a class="xref" href="buffer.html#v4l2-memory" title="Table&#160;3.5.&#160;enum v4l2_memory">Table&#160;3.5, &#8220;enum v4l2_memory&#8221;</a>.</td></tr><tr><td valign="top">__u32</td><td valign="top"><em class="structfield"><code>reserved</code></em>[2]</td><td valign="top">A place holder for future extensions. This array should
be zeroed by applications.</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="refsect1" title="Return Value"><a id="idp36108952"></a><h2>Return Value</h2><p>On success <span class="returnvalue">0</span> is returned, on error <span class="returnvalue">-1</span> and the <code class="varname">errno</code> variable is set appropriately. The generic error codes are described at the <a class="link" href="gen_errors.html#gen-errors" title="Table&#160;19.1.&#160;Generic error codes">Generic Error Codes</a> chapter.</p><div class="variablelist"><dl><dt><span class="term"><span class="errorcode">EINVAL</span></span></dt><dd><p>The buffer type (<em class="structfield"><code>type</code></em> field) or the
requested I/O method (<em class="structfield"><code>memory</code></em>) is not
supported.</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="vidioc-querystd.html">Prev</a>&#160;</td><td width="20%" align="center"><a accesskey="u" href="user-func.html">Up</a></td><td width="40%" align="right">&#160;<a accesskey="n" href="vidioc-s-hw-freq-seek.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">ioctl VIDIOC_QUERYSTD&#160;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&#160;ioctl VIDIOC_S_HW_FREQ_SEEK</td></tr></table></div></body></html>
